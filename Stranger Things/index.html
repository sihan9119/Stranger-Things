<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Vecna Control - Toggle Camera</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }

        /* æ‘„åƒå¤´ç”»é¢ */
        #video-container {
            position: absolute;
            top: 0; left: 0; width: 200px; height: 150px;
            z-index: 999;
            opacity: 1.0; /* é»˜è®¤æ˜¾ç¤º */
            transform: scaleX(-1);
            pointer-events: none;
            border: 2px solid #500;
            transition: opacity 0.5s ease; /* æ·»åŠ æ·¡å…¥æ·¡å‡ºè¿‡æ¸¡æ•ˆæœ */
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0000; font-family: 'Courier New', sans-serif; pointer-events: none;
            text-shadow: 0 0 10px red; font-size: 20px; font-weight: bold; letter-spacing: 2px;
            z-index: 100;
        }

        /* æŒ‰é’®é€šç”¨æ ·å¼ */
        .hell-btn {
            position: absolute; bottom: 30px;
            padding: 12px 20px; background-color: rgba(20, 0, 0, 0.9);
            color: #880000; border: 1px solid #550000;
            font-family: 'Courier New', monospace; font-size: 14px; cursor: pointer;
            z-index: 20; box-shadow: 0 0 10px #330000; transition: all 0.3s;
            text-transform: uppercase; letter-spacing: 1px;
            user-select: none;
        }
        .hell-btn:hover { background-color: #550000; color: #fff; box-shadow: 0 0 30px #ff0000; border-color: #ff0000; }

        #reset-btn { left: 50%; transform: translateX(-50%); }
        #fullscreen-btn { right: 30px; }
        /* [æ–°å¢] æ‘„åƒå¤´å¼€å…³æŒ‰é’®ï¼Œæ”¾åœ¨å…¨å±æŒ‰é’®å·¦ä¾§ */
        #cam-btn { right: 210px; }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="loading">åœ°ç‹±ä¹‹é—¨å¼€å¯ä¸­...</div>
<div id="video-container"><video id="input_video"></video></div>

<button id="reset-btn" class="hell-btn" onclick="resetScene()">Reset Ritual</button>
<button id="cam-btn" class="hell-btn" onclick="toggleCamera()">[ ğŸ‘ ] Hide Cam</button>
<button id="fullscreen-btn" class="hell-btn" onclick="toggleFullscreen()">[ ] Fullscreen</button>

<script>
    // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a1f33, 0.012);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // --- ç¯å…‰ç³»ç»Ÿ (å›ºå®šå‚æ•°) ---
    const ambientLight = new THREE.AmbientLight(0x170202, 1.0);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0x240a0a, 3.85);
    mainLight.position.set(5, 10, 7);
    scene.add(mainLight);

    const hellLight = new THREE.DirectionalLight(0xcc0000, 4.35);
    hellLight.position.set(-5, 5, -10);
    scene.add(hellLight);

    // --- èƒŒæ™¯çº¹ç† ---
    const textureLoader = new THREE.TextureLoader();
    let bgMesh;
    let updateBackgroundCover;

    textureLoader.load('background.png', (texture) => {
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const bgDist = -150;
        const bgMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            depthWrite: false,
            fog: false,
            color: 0x9b5959
        });

        bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), bgMaterial);
        bgMesh.position.set(0, 1, bgDist);
        scene.add(bgMesh);

        updateBackgroundCover = function() {
            if (!bgMesh || !bgMesh.material.map || !bgMesh.material.map.image) return;
            const texture = bgMesh.material.map;
            const windowAspect = window.innerWidth / window.innerHeight;
            const imageAspect = texture.image.width / texture.image.height;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * (camera.position.z - bgMesh.position.z);
            const visibleWidth = visibleHeight * windowAspect;

            bgMesh.geometry.dispose();
            bgMesh.geometry = new THREE.PlaneGeometry(visibleWidth * 1.02, visibleHeight * 1.02);

            if (windowAspect > imageAspect) {
                texture.repeat.set(1, imageAspect / windowAspect);
                texture.offset.set(0, (1 - texture.repeat.y) / 2);
            } else {
                texture.repeat.set(windowAspect / imageAspect, 1);
                texture.offset.set((1 - texture.repeat.x) / 2, 0);
            }
            texture.needsUpdate = true;
        };
        updateBackgroundCover();
    });

    // --- 2. ç²’å­ Shader ---
    const particleVertexShader = `
        uniform float uTime;
        uniform float uBurst;
        attribute vec3 randomDir;
        attribute float randomScale;
        attribute vec3 aColor;
        varying float vAlpha;
        varying vec3 vColor;
        void main() {
            vColor = aColor;
            vec3 pos = position;
            if (uBurst > 0.5) {
                pos.x += randomDir.x * uTime * 2.0;
                pos.y += (randomDir.y + 1.0) * uTime * 1.5;
                pos.z += randomDir.z * uTime * 2.0;
            }
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = (30.0 + randomScale * 10.0) * (1.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
            vAlpha = 0.3 - (uTime * 0.05);
            if (vAlpha < 0.0) vAlpha = 0.0;
        }
    `;
    const particleFragmentShader = `
        varying float vAlpha;
        varying vec3 vColor;
        void main() {
            if (vAlpha <= 0.0) discard;
            vec2 coord = gl_PointCoord - vec2(0.5);
            if(length(coord) > 0.5) discard;
            gl_FragColor = vec4(vColor, vAlpha);
        }
    `;

    // --- 3. æ¨¡å‹ç³»ç»Ÿ ---
    let demonWrapper = new THREE.Group();
    let demonMesh = null;
    let demonParticles = null;
    scene.add(demonWrapper);

    const INITIAL_POS = { x: 0, y: -7, z: -25 };
    const INITIAL_ROT_Y = -Math.PI / 2;

    const state = { isLoaded: false, stage: 'IDLE', isShaking: false };

    const loader = new THREE.GLTFLoader();
    loader.load('model.glb', (gltf) => {
        const model = gltf.scene;
        demonWrapper.position.set(INITIAL_POS.x, INITIAL_POS.y, INITIAL_POS.z);
        model.scale.set(10.4, 10.4, 10.4);
        model.rotation.y = INITIAL_ROT_Y;

        const vertices = [], randomDirs = [], randomScales = [], colors = [];
        model.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                const pos = child.geometry.attributes.position;
                const count = pos.count;
                const tempVec = new THREE.Vector3();
                for(let i=0; i < count; i+=3) {
                    tempVec.fromBufferAttribute(pos, i);
                    vertices.push(tempVec.x, tempVec.y, tempVec.z);
                    randomDirs.push((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
                    randomScales.push(Math.random());
                    const rand = Math.random();
                    if (rand > 0.7) colors.push(0.9, 0.9, 1.0);
                    else if (rand > 0.4) colors.push(1.0, 0.5, 0.1);
                    else colors.push(1.0, 1.0, 1.0);
                }
            }
        });

        demonMesh = model;
        demonWrapper.add(demonMesh);

        const particleGeo = new THREE.BufferGeometry();
        particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        particleGeo.setAttribute('randomDir', new THREE.Float32BufferAttribute(randomDirs, 3));
        particleGeo.setAttribute('randomScale', new THREE.Float32BufferAttribute(randomScales, 1));
        particleGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));

        const particleMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uBurst: { value: 0 } },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true, depthWrite: false, side: THREE.DoubleSide
        });

        demonParticles = new THREE.Points(particleGeo, particleMat);
        demonParticles.visible = false;
        scene.add(demonParticles);
        document.getElementById('loading').style.display = 'none';
        state.isLoaded = true;
    });

    // --- 4. åŠ¨ç”»æ§åˆ¶ ---
    function triggerAscend() {
        if (state.stage !== 'IDLE') return;
        state.stage = 'RISING'; state.isShaking = true;
        gsap.to(demonWrapper.position, {
            y: 15.0, duration: 5.5, ease: "power2.inOut",
            onComplete: () => { state.stage = 'HOVERING_HIGH'; state.isShaking = true; }
        });
    }

    function triggerPullDown() {
        if (state.stage !== 'HOVERING_HIGH') return;
        state.stage = 'MOVING_DOWN'; state.isShaking = true;
        gsap.to(demonWrapper.position, { x: 0, y: 0, z: -8, duration: 3.5, ease: "power3.out", onComplete: () => { state.stage = 'HOVERING_NEAR'; state.isShaking = true; } });
    }

    function triggerAsh() {
        if (state.stage !== 'HOVERING_NEAR') return;
        state.stage = 'DISSOLVING'; state.isShaking = false;

        demonParticles.position.copy(demonWrapper.position);
        demonParticles.rotation.copy(demonMesh.rotation);
        demonParticles.scale.copy(demonMesh.scale);

        demonMesh.visible = false;
        demonParticles.visible = true;
        demonParticles.material.uniforms.uBurst.value = 1.0;
        demonParticles.material.uniforms.uTime.value = 0.1;

        gsap.to(demonParticles.material.uniforms.uTime, {
            value: 12.0, duration: 8.0, ease: "linear"
        });
    }

    window.resetScene = function() {
        if (!state.isLoaded) return;
        gsap.killTweensOf(demonWrapper.position);
        gsap.killTweensOf(demonMesh.rotation);
        gsap.killTweensOf(demonParticles.material.uniforms.uTime);
        state.stage = 'IDLE'; state.isShaking = false;
        demonMesh.visible = true;
        demonMesh.position.set(0,0,0);
        demonMesh.rotation.y = INITIAL_ROT_Y;
        demonWrapper.position.set(INITIAL_POS.x, INITIAL_POS.y, INITIAL_POS.z);
        demonParticles.visible = false;
        demonParticles.material.uniforms.uTime.value = 0;
        demonParticles.material.uniforms.uBurst.value = 0;
    };

    window.toggleFullscreen = function() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => console.log(err));
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    };

    // [æ–°å¢] æ‘„åƒå¤´åˆ‡æ¢åŠŸèƒ½
    window.toggleCamera = function() {
        const vid = document.getElementById('video-container');
        const btn = document.getElementById('cam-btn');
        if (vid.style.opacity === '0') {
            vid.style.opacity = '1.0';
            btn.innerText = '[ ğŸ‘ ] Hide Cam';
        } else {
            vid.style.opacity = '0';
            btn.innerText = '[ âœ– ] Show Cam';
        }
    };

    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        if (state.isShaking && demonMesh) {
            let shakeAmp = (state.stage === 'RISING' || state.stage === 'HOVERING_HIGH') ? 0.3 : 0.2;
            demonMesh.position.set((Math.random()-0.5)*shakeAmp, (Math.random()-0.5)*shakeAmp, (Math.random()-0.5)*shakeAmp);
        } else if (demonMesh && !state.stage.includes('DISSOLVING')) {
            demonMesh.position.set(0,0,0);
        }
        if (state.stage === 'HOVERING_HIGH' || state.stage === 'HOVERING_NEAR') {
            demonWrapper.position.y += Math.sin(time * 2) * 0.01;
        }
        renderer.render(scene, camera);
    }
    animate();

    function onResults(results) {
        if (!state.isLoaded) return;
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const fingers = detectFingers(landmarks);

            if (state.stage === 'IDLE') {
                if (fingers >= 3) triggerAscend();
            }
            else if (state.stage === 'HOVERING_HIGH') {
                if (fingers <= 1) triggerPullDown();
            }
            else if (state.stage === 'HOVERING_NEAR') {
                if (fingers > 1) triggerAsh();
            }
        }
    }

    function detectFingers(landmarks) {
        let fingers = 0;
        const tips = [8, 12, 16, 20], pips = [6, 10, 14, 18];
        tips.forEach((t, i) => { if(landmarks[t].y < landmarks[pips[i]].y) fingers++; });
        if (Math.abs(landmarks[4].x - landmarks[2].x) > Math.abs(landmarks[3].x - landmarks[2].x) * 1.5) fingers++;
        return fingers;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(document.getElementById('input_video'), {
        onFrame: async () => await hands.send({image: document.getElementById('input_video')}),
        width: 320, height: 240
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (updateBackgroundCover) updateBackgroundCover();
    });
</script>
</body>
</html>